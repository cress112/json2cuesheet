use super::file::{File, FileFormatter};
use super::info::{Info, InfoFormatter};
use crate::share::util;

pub struct Cue<I: InfoFormatter = Info, F: FileFormatter = File> {
    title: String,
    genre: Option<String>,
    info: Option<I>,
    files: Vec<F>,
}

impl<I: InfoFormatter, F: FileFormatter> Cue<I, F> {
    const KEY_TITLE: &str = "TITLE";
    const KEY_GENRE: &str = "REM GENRE";
    const STATIC_COMMENTS: [&str; 2] = ["REM CDRTOOLS", "REM COMMENT Generated by Json2Cue"];

    pub fn new(title: String, genre: Option<String>, info: Option<I>, files: Vec<F>) -> Cue<I, F> {
        Cue {
            title,
            genre,
            info,
            files,
        }
    }

    pub fn to_cdtext_string(&self) -> Result<String, String> {
        let mut lines: Vec<String> = Vec::new();

        // title
        lines.push(format!("{} \"{}\"", Self::KEY_TITLE, self.title));
        // static comments
        lines.extend(Self::STATIC_COMMENTS.map(|s| String::from(s)));
        // genre
        if let Some(genre_string) = &self.genre {
            lines.push(format!("{} \"{}\"", Self::KEY_GENRE, genre_string));
        };
        // info
        if let Some(info) = &self.info {
            lines.extend(info.to_cdtext_strings(false));
        }
        // files
        for file in self.files.iter() {
            let file_result = match file.to_cdtext_strings() {
                Ok(res) => res,
                Err(res) => {
                    return Err(res);
                }
            };
            lines.extend(file_result);
        }

        Ok(util::join_strings_with_lf(&lines))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    const TEST_INFO: [&str; 2] = ["info1", "info2"];
    const TEST_FILE: [&str; 3] = ["file", "  strings", "    are here"];

    struct MockInfo {}
    impl InfoFormatter for MockInfo {
        fn to_cdtext_strings(&self, indent: bool) -> Vec<String> {
            let mut result: Vec<String> = Vec::new();
            if indent {
                result.extend(TEST_INFO.map(|s| format!("  {s}")));
                return result;
            }
            result.extend(TEST_INFO.iter().map(|s| String::from(*s)));
            result
        }
    }

    struct MockFile {}
    impl FileFormatter for MockFile {
        fn to_cdtext_strings(&self) -> Result<Vec<String>, String> {
            let strings = TEST_FILE.map(|s| String::from(s));
            return Ok(Vec::from(strings));
        }
    }

    #[test]
    fn test_to_cdtext_string() -> Result<(), Box<dyn std::error::Error>> {
        let title = String::from("これがタイトル");
        let genre = Some(String::from("スーパーロック"));
        let info = Some(MockInfo {});
        let files = vec![MockFile {}, MockFile {}];
        let cue = Cue::new(title, genre, info, files);

        let result = cue.to_cdtext_string()?;

        let expected = vec![
            "TITLE \"これがタイトル\"",
            "REM CDRTOOLS",
            "REM COMMENT Generated by Json2Cue",
            "REM GENRE \"スーパーロック\"",
            "info1",
            "info2",
            "file",
            "  strings",
            "    are here",
            "file",
            "  strings",
            "    are here",
        ];
        assert_eq!(result, expected.join("\n"));
        Ok(())
    }
}
